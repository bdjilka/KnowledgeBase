import {mTypes as mutations} from './mutations';
import {aTypes as appActions} from '../app/actions';
import * as api from '../../api';
import {dispatch} from '../../store/utils';
import router from '../../router/index';
import jwt_decode from 'jwt-decode';
import {fromStorage} from '../../utils';
import {savingValues} from './const';

export const aTypes = {
    login: 'auth/login',
    logout: 'auth/logout',
    refresh: 'auth/refresh',
    updateUserInfo: 'auth/updateUserInfo',
    inspectToken: 'auth/inspectToken',
    signup: 'auth/signup'
};

export const actions = {
    async login(cntx, {username, pswd}) {
        /**
         * Logs in user: creates new token and saves personal user information
         * @param {string} username
         * @param {string} pswd
         */
        try {
            dispatch(cntx, appActions.changeLoading);

            let data = {};
            await api.login(username, pswd)
                .then(response => {
                    data = response.data;
                });
            cntx.commit(mutations.UPDATE_USER_INFO, jwt_decode(data.token));
            await dispatch(cntx, aTypes.updateUserInfo);

            await router.push('/dashboard');
        } catch (e) {
           alert('Sign in error: ' + e);
        } finally {
            dispatch(cntx, appActions.changeLoading);
        }
    },

    async updateUserInfo(cntx) {
        /**
         * Gets and saves personal user information.
         */
        try {
            dispatch(cntx, appActions.changeLoading);

            const {data} = await api.getUserInfo(cntx.getters.id);
            cntx.commit(mutations.UPDATE_USER_DATA, data);
        } catch (e) {
            alert('Error getting user data: ' + e);
        } finally {
            dispatch(cntx, appActions.changeLoading);
        }
    },

    async logout(cntx) {
        /**
         * Logs out user: delete its token from store and session storage.
         */
        try {
            dispatch(cntx, appActions.changeLoading);
            cntx.commit(mutations.CLEAR_TOKEN);
            sessionStorage.clear();
        } catch (e) {
            alert('Exit error: ' + e);
        } finally {
            dispatch(cntx, appActions.changeLoading);
        }
    },

    async refresh(cntx, token) {
        /**
         * Refreshes user token.
         * @param {string} token.
         */
        try {
            dispatch(cntx, appActions.changeLoading);

            const {data} = await api.refresh(token);
            cntx.commit(mutations.UPDATE_TOKEN, jwt_decode(data.token));
            return true;
        } catch (e) {
            alert('Token update error: ' +  e);
            return false;
        } finally {
            dispatch(cntx, appActions.changeLoading);
        }
    },

    async inspectToken(cntx) {
        /**
         * Checks whether it needed to update token every 30 minutes.
         */
        try {
            let token = fromStorage(savingValues.token);
            if (token) {
                // 60s*50 = 3000s == 50 minutes
                if ((new Date(token * 1000) - new Date()) / 1000 <= 3000) {
                    await dispatch(cntx, aTypes.refresh, token);
                    return;
                }
                if ((new Date(token * 1000) - new Date()) < 0) {
                    await dispatch(cntx, aTypes.logout);
                }
            } else {
                await dispatch(cntx, aTypes.logout);
            }
        } catch (e) {
            alert('error during inspectToken: ' + e);
            await dispatch(cntx, aTypes.logout);
        }
    },

    async signup(cntx, {username, pswd, email}) {
        /**
         * Sighs up user: creates new instance of user in data base
         * @param {string} username
         * @param {string} pswd
         * @param {string} email
         */
        try {
            dispatch(cntx, appActions.changeLoading);

            await api.signup(username, pswd, email)
                .then(async () => {
                    await dispatch(cntx, aTypes.login, {username, pswd});
                });

        } catch (e) {
           alert('Sign up error: ' + e);
        } finally {
            dispatch(cntx, appActions.changeLoading);
        }
    },
};